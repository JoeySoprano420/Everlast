let X = 10;
rule IsEven(X) :- X mod 2 == 0;
query(IsEven);

let X = 10;
rule IsEven(X) :- X mod 2 == 0;
query(IsEven);

let X = 25;
let Y = 5;
let result;

rule IsDivisible(X, Y) :- X mod Y == 0;
rule DivCheck(X, Y, result) :- IsDivisible(X, Y) ? (result = "Divisible") : (result = "Not Divisible");

query(DivCheck(X, Y, result));

In the Everlast programming language, using the Outcome-Driven-Instruction Paradigm (ODI), the syntax is designed to express high-level goals or outcomes in a declarative style. Instead of focusing on the exact steps, the language allows the programmer to define conditions and desired outcomes, which are later translated into hexadecimal and machine code.

Here is an example of how the syntax could be structured:

Basic Syntax Structure
	1.	Variables and Assignment
	•	Variables are declared and assigned values using the let keyword. This is followed by the variable name and the assignment operator.
	•	Example:

let X = 10;
let Y = 5;


	2.	Rules and Logic
	•	Rules are defined using the rule keyword. A rule defines conditions and outcomes that should be true for the system.
	•	Rules can involve mathematical operations, logical comparisons, and more.
	•	Example:

rule IsEven(X) :- X mod 2 == 0;


	3.	Queries
	•	Queries are used to evaluate whether certain rules or conditions hold true.
	•	Example:

query(IsEven(X));


	4.	Operators
	•	Operators can be used for mathematical and logical operations like +, -, *, /, mod, ==, <, >, <=, >=, and, or, and not.
	•	Example:

let Z = X + Y;
rule IsGreaterThan(Z, 10) :- Z > 10;


	5.	Control Structures
	•	Conditional and loop structures can be added. In this case, they are mapped into rules that represent constraints and outcomes.
	•	Example of conditional:

rule IsGreaterThan(X, Y) :- X > Y;
rule Result(X) :- IsGreaterThan(X, 5);



Example Code

Let’s take a look at an example that demonstrates a few concepts together:

// Declare variables
let X = 10;
let Y = 5;
let Z;

// Define a rule to check if X is even
rule IsEven(X) :- X mod 2 == 0;

// Define a rule to check if X is greater than Y
rule IsGreaterThan(X, Y) :- X > Y;

// Define a rule to compute the sum of X and Y
rule Sum(X, Y, Z) :- Z = X + Y;

// Query the results
query(IsEven(X));
query(IsGreaterThan(X, Y));
query(Sum(X, Y, Z));

Breakdown of the Conversion Table:
	•	let X = 10; could map to:
	•	let → 0x01
	•	X → 0x05 (variable)
	•	= 10 → 0x10 (assignment)
	•	rule IsEven(X) :- X mod 2 == 0; could map to:
	•	rule → 0x02
	•	IsEven(X) → 0xA1 (rule identifier)
	•	mod → 0xA3
	•	== → 0x9F
	•	query(IsEven(X)); could map to:
	•	query → 0x03
	•	IsEven(X) → 0xA1

After compiling the code, these higher-level constructs are translated into the corresponding hexadecimal representations and ultimately into machine-readable binary instructions for execution.

Example of a Simple Program in Everlast:

// Declare variables
let A = 20;
let B = 15;
let SumResult;

// Define rule for checking even numbers
rule IsEven(A) :- A mod 2 == 0;

// Define rule to sum two variables
rule Sum(A, B, SumResult) :- SumResult = A + B;

// Execute queries
query(IsEven(A));
query(Sum(A, B, SumResult));

Output Example:

After parsing the above code, the language would generate the following hexadecimal instructions (for example):

0x01 0x05 0x10   // let A = 20
0x01 0x06 0x15   // let B = 15
0x02 0xA1 0xA3 0x05 0x9F 0x00 0xA3 0x00   // rule IsEven(A) :- A mod 2 == 0
0x02 0xA2 0xA3 0x05 0x06 0x0F 0x10   // rule Sum(A, B, SumResult) :- SumResult = A + B
0x03 0xA1   // query(IsEven(A))
0x03 0xA2   // query(Sum(A, B, SumResult))

This will then be converted into bytecode and finally into binary that can be executed by the machine.

Summary of Key Features:
	1.	Declarative Syntax: The focus is on specifying what needs to happen, not how to do it.
	2.	Conversion Table: Maps high-level constructs to hexadecimal values that are compiled into efficient binary code.
	3.	Efficient Execution: The final binary code is optimized for execution by the machine.
	4.	Human-Readable: The syntax is intuitive and easy to understand, focusing on desired outcomes.

In Everlast, you define your goals (outcomes) and let the language handle the low-level details of execution. This allows for both high-level expressiveness and low-level performance optimization.
